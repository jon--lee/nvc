# effectively, this method compiles a list of "squares" which are matrices
    # where the number of elements equals the number of inputs for the network.
    # squares are generated by splitting the matrix into row blocks and then splitting
    # each row block into squares. The squares are squished down to 1 dimension and 
    # concatenated into one long vector
    def _vectorize(self, arr):
        h,w = arr.shape
        max_ = self.net.start.size      # total size of input vector
        length = max_ ** .5             # length of the squares of the feature map
        row_blocks = np.split(arr, h / length)

        squares = []
        for row_block in row_blocks:
            chunks = np.split(row_block, w / length, axis=1)
            for chunk in chunks:
                squares.append(chunk)

        vec = np.array([])
        for square in squares:
            vec = np.concatenate((vec, np.reshape(square, (max_))))

        return vec